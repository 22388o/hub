// Code generated by protoc-gen-go. DO NOT EDIT.
// source: log.proto

/*
Package logger is a generated protocol buffer package.

It is generated from these files:
	log.proto

It has these top-level messages:
	Log
	RouterState
	Channel
	Payment
	ChannelChange
*/
package logger

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type PaymentStatus int32

const (
	PaymentStatus_success PaymentStatus = 0
	// UnsufficientFunds means that router haven't posses/locked enough funds
	// with receiver user to route thouth the payment.
	PaymentStatus_unsufficient_funds PaymentStatus = 1
	// ExternalFail means that receiver failed to receive payment because of
	// the unknown to us reason.
	PaymentStatus_external_fail PaymentStatus = 2
)

var PaymentStatus_name = map[int32]string{
	0: "success",
	1: "unsufficient_funds",
	2: "external_fail",
}
var PaymentStatus_value = map[string]int32{
	"success":            0,
	"unsufficient_funds": 1,
	"external_fail":      2,
}

func (x PaymentStatus) String() string {
	return proto.EnumName(PaymentStatus_name, int32(x))
}
func (PaymentStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// ChannelChangeType represent the type of action which were attempted to
// apply to the channel.
type ChannelChangeType int32

const (
	// Open is used when this channel was just created, and haven't been in
	// local network before
	ChannelChangeType_open ChannelChangeType = 0
	// Close is used when number locked funds / balances of both channel
	// participant equal to zero.
	ChannelChangeType_close ChannelChangeType = 1
	// Udpate is used when one of the participants decides to update its
	// channel balance.
	ChannelChangeType_udpate ChannelChangeType = 2
)

var ChannelChangeType_name = map[int32]string{
	0: "open",
	1: "close",
	2: "udpate",
}
var ChannelChangeType_value = map[string]int32{
	"open":   0,
	"close":  1,
	"udpate": 2,
}

func (x ChannelChangeType) String() string {
	return proto.EnumName(ChannelChangeType_name, int32(x))
}
func (ChannelChangeType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// Log is the main object in the file which represent the log entry in the
// log file.
type Log struct {
	Time int64 `protobuf:"varint,1,opt,name=time" json:"time,omitempty"`
	// Types that are valid to be assigned to Data:
	//	*Log_State
	//	*Log_Payment
	//	*Log_ChannelChange
	Data isLog_Data `protobuf_oneof:"data"`
}

func (m *Log) Reset()                    { *m = Log{} }
func (m *Log) String() string            { return proto.CompactTextString(m) }
func (*Log) ProtoMessage()               {}
func (*Log) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type isLog_Data interface {
	isLog_Data()
}

type Log_State struct {
	State *RouterState `protobuf:"bytes,2,opt,name=state,oneof"`
}
type Log_Payment struct {
	Payment *Payment `protobuf:"bytes,3,opt,name=payment,oneof"`
}
type Log_ChannelChange struct {
	ChannelChange *ChannelChange `protobuf:"bytes,4,opt,name=channel_change,json=channelChange,oneof"`
}

func (*Log_State) isLog_Data()         {}
func (*Log_Payment) isLog_Data()       {}
func (*Log_ChannelChange) isLog_Data() {}

func (m *Log) GetData() isLog_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Log) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *Log) GetState() *RouterState {
	if x, ok := m.GetData().(*Log_State); ok {
		return x.State
	}
	return nil
}

func (m *Log) GetPayment() *Payment {
	if x, ok := m.GetData().(*Log_Payment); ok {
		return x.Payment
	}
	return nil
}

func (m *Log) GetChannelChange() *ChannelChange {
	if x, ok := m.GetData().(*Log_ChannelChange); ok {
		return x.ChannelChange
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Log) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Log_OneofMarshaler, _Log_OneofUnmarshaler, _Log_OneofSizer, []interface{}{
		(*Log_State)(nil),
		(*Log_Payment)(nil),
		(*Log_ChannelChange)(nil),
	}
}

func _Log_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Log)
	// data
	switch x := m.Data.(type) {
	case *Log_State:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.State); err != nil {
			return err
		}
	case *Log_Payment:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Payment); err != nil {
			return err
		}
	case *Log_ChannelChange:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ChannelChange); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Log.Data has unexpected type %T", x)
	}
	return nil
}

func _Log_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Log)
	switch tag {
	case 2: // data.state
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RouterState)
		err := b.DecodeMessage(msg)
		m.Data = &Log_State{msg}
		return true, err
	case 3: // data.payment
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Payment)
		err := b.DecodeMessage(msg)
		m.Data = &Log_Payment{msg}
		return true, err
	case 4: // data.channel_change
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ChannelChange)
		err := b.DecodeMessage(msg)
		m.Data = &Log_ChannelChange{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Log_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Log)
	// data
	switch x := m.Data.(type) {
	case *Log_State:
		s := proto.Size(x.State)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Log_Payment:
		s := proto.Size(x.Payment)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Log_ChannelChange:
		s := proto.Size(x.ChannelChange)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// RouterState is a type of log entry which describes the state/view of the
// router local lightning network and number of free funds which exist under
// control router.
type RouterState struct {
	// Channels represent the local lightning network topology.
	Channels []*Channel `protobuf:"bytes,1,rep,name=channels" json:"channels,omitempty"`
	// FreeBalance it is free number of funds under router managment which
	// could be used to lock them in the channels.
	FreeBalance uint64 `protobuf:"varint,2,opt,name=free_balance,json=freeBalance" json:"free_balance,omitempty"`
	// PendingBalance is the amount of funds which in the process of
	// being accepted by blockchain.
	PendingBalance uint64 `protobuf:"varint,3,opt,name=pending_balance,json=pendingBalance" json:"pending_balance,omitempty"`
	// AverageChangeUpdateDuration is number of milliseconds which
	// is needed to change of state of chanel over blockchain.
	AverageChangeUpdateDuration uint64 `protobuf:"varint,4,opt,name=average_change_update_duration,json=averageChangeUpdateDuration" json:"average_change_update_duration,omitempty"`
}

func (m *RouterState) Reset()                    { *m = RouterState{} }
func (m *RouterState) String() string            { return proto.CompactTextString(m) }
func (*RouterState) ProtoMessage()               {}
func (*RouterState) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *RouterState) GetChannels() []*Channel {
	if m != nil {
		return m.Channels
	}
	return nil
}

func (m *RouterState) GetFreeBalance() uint64 {
	if m != nil {
		return m.FreeBalance
	}
	return 0
}

func (m *RouterState) GetPendingBalance() uint64 {
	if m != nil {
		return m.PendingBalance
	}
	return 0
}

func (m *RouterState) GetAverageChangeUpdateDuration() uint64 {
	if m != nil {
		return m.AverageChangeUpdateDuration
	}
	return 0
}

// Channel is used as the building block in describing of the lightning
// network topology.
type Channel struct {
	UserId        uint64 `protobuf:"varint,1,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	ChannelId     uint64 `protobuf:"varint,2,opt,name=channel_id,json=channelId" json:"channel_id,omitempty"`
	UserBalance   uint64 `protobuf:"varint,3,opt,name=user_balance,json=userBalance" json:"user_balance,omitempty"`
	RouterBalance uint64 `protobuf:"varint,4,opt,name=router_balance,json=routerBalance" json:"router_balance,omitempty"`
	IsPending     bool   `protobuf:"varint,5,opt,name=is_pending,json=isPending" json:"is_pending,omitempty"`
}

func (m *Channel) Reset()                    { *m = Channel{} }
func (m *Channel) String() string            { return proto.CompactTextString(m) }
func (*Channel) ProtoMessage()               {}
func (*Channel) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Channel) GetUserId() uint64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *Channel) GetChannelId() uint64 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *Channel) GetUserBalance() uint64 {
	if m != nil {
		return m.UserBalance
	}
	return 0
}

func (m *Channel) GetRouterBalance() uint64 {
	if m != nil {
		return m.RouterBalance
	}
	return 0
}

func (m *Channel) GetIsPending() bool {
	if m != nil {
		return m.IsPending
	}
	return false
}

// Payment represent the attempt of peer in the local lightning network to
// send the payment to some another peer in the network.
type Payment struct {
	Status   PaymentStatus `protobuf:"varint,1,opt,name=status,enum=logger.PaymentStatus" json:"status,omitempty"`
	Sender   uint64        `protobuf:"varint,2,opt,name=sender" json:"sender,omitempty"`
	Receiver uint64        `protobuf:"varint,3,opt,name=receiver" json:"receiver,omitempty"`
	Amount   uint64        `protobuf:"varint,5,opt,name=amount" json:"amount,omitempty"`
	// Earned is the number of funds which router earned by making this payment.
	// In case of rebalncing router will pay the fee, for that reason this
	// number will be negative.
	Earned int64 `protobuf:"varint,6,opt,name=earned" json:"earned,omitempty"`
}

func (m *Payment) Reset()                    { *m = Payment{} }
func (m *Payment) String() string            { return proto.CompactTextString(m) }
func (*Payment) ProtoMessage()               {}
func (*Payment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Payment) GetStatus() PaymentStatus {
	if m != nil {
		return m.Status
	}
	return PaymentStatus_success
}

func (m *Payment) GetSender() uint64 {
	if m != nil {
		return m.Sender
	}
	return 0
}

func (m *Payment) GetReceiver() uint64 {
	if m != nil {
		return m.Receiver
	}
	return 0
}

func (m *Payment) GetAmount() uint64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *Payment) GetEarned() int64 {
	if m != nil {
		return m.Earned
	}
	return 0
}

type ChannelChange struct {
	Type          ChannelChangeType `protobuf:"varint,1,opt,name=type,enum=logger.ChannelChangeType" json:"type,omitempty"`
	UserId        uint64            `protobuf:"varint,2,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	ChannelId     uint64            `protobuf:"varint,3,opt,name=channel_id,json=channelId" json:"channel_id,omitempty"`
	UserBalance   uint64            `protobuf:"varint,4,opt,name=user_balance,json=userBalance" json:"user_balance,omitempty"`
	RouterBalance uint64            `protobuf:"varint,5,opt,name=router_balance,json=routerBalance" json:"router_balance,omitempty"`
	// Fee which was taken by blockchain decentrilized computer / mainers or
	// some other form of smart contract manager.
	Fee uint64 `protobuf:"varint,6,opt,name=fee" json:"fee,omitempty"`
}

func (m *ChannelChange) Reset()                    { *m = ChannelChange{} }
func (m *ChannelChange) String() string            { return proto.CompactTextString(m) }
func (*ChannelChange) ProtoMessage()               {}
func (*ChannelChange) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ChannelChange) GetType() ChannelChangeType {
	if m != nil {
		return m.Type
	}
	return ChannelChangeType_open
}

func (m *ChannelChange) GetUserId() uint64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ChannelChange) GetChannelId() uint64 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *ChannelChange) GetUserBalance() uint64 {
	if m != nil {
		return m.UserBalance
	}
	return 0
}

func (m *ChannelChange) GetRouterBalance() uint64 {
	if m != nil {
		return m.RouterBalance
	}
	return 0
}

func (m *ChannelChange) GetFee() uint64 {
	if m != nil {
		return m.Fee
	}
	return 0
}

func init() {
	proto.RegisterType((*Log)(nil), "logger.Log")
	proto.RegisterType((*RouterState)(nil), "logger.RouterState")
	proto.RegisterType((*Channel)(nil), "logger.Channel")
	proto.RegisterType((*Payment)(nil), "logger.Payment")
	proto.RegisterType((*ChannelChange)(nil), "logger.ChannelChange")
	proto.RegisterEnum("logger.PaymentStatus", PaymentStatus_name, PaymentStatus_value)
	proto.RegisterEnum("logger.ChannelChangeType", ChannelChangeType_name, ChannelChangeType_value)
}

func init() { proto.RegisterFile("log.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 562 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x94, 0xd1, 0x6e, 0xd3, 0x3e,
	0x14, 0xc6, 0xeb, 0x26, 0x4d, 0xdb, 0xd3, 0x7f, 0xbb, 0xcc, 0x7f, 0x31, 0x02, 0x68, 0xa8, 0x54,
	0x42, 0x4c, 0x9b, 0xb6, 0x0b, 0xe0, 0x9a, 0x8b, 0x15, 0x89, 0x4e, 0xe2, 0x62, 0xf2, 0xe0, 0x3a,
	0xf2, 0xe2, 0x93, 0x10, 0x29, 0x75, 0x22, 0xdb, 0x99, 0xe8, 0xbb, 0xf0, 0x04, 0xbc, 0x02, 0x8f,
	0xc0, 0x1d, 0x4f, 0x84, 0xe2, 0x38, 0xa5, 0x15, 0x13, 0x70, 0x55, 0x9f, 0xcf, 0xbf, 0x53, 0x7d,
	0xc7, 0xdf, 0x51, 0x60, 0x5c, 0x94, 0xd9, 0x45, 0xa5, 0x4a, 0x53, 0xd2, 0xa0, 0x28, 0xb3, 0x0c,
	0xd5, 0xe2, 0x1b, 0x01, 0xef, 0x7d, 0x99, 0x51, 0x0a, 0xbe, 0xc9, 0xd7, 0x18, 0x91, 0x39, 0x39,
	0xf1, 0x98, 0x3d, 0xd3, 0x33, 0x18, 0x68, 0xc3, 0x0d, 0x46, 0xfd, 0x39, 0x39, 0x99, 0xbc, 0xfc,
	0xff, 0xa2, 0xed, 0xb9, 0x60, 0x65, 0x6d, 0x50, 0xdd, 0x34, 0x57, 0xab, 0x1e, 0x6b, 0x19, 0x7a,
	0x06, 0xc3, 0x8a, 0x6f, 0xd6, 0x28, 0x4d, 0xe4, 0x59, 0xfc, 0xa0, 0xc3, 0xaf, 0x5b, 0x79, 0xd5,
	0x63, 0x1d, 0x41, 0xdf, 0xc0, 0x2c, 0xf9, 0xc4, 0xa5, 0xc4, 0x22, 0x6e, 0x7e, 0x33, 0x8c, 0x7c,
	0xdb, 0xf3, 0xa0, 0xeb, 0x59, 0xb6, 0xb7, 0x4b, 0x7b, 0xb9, 0xea, 0xb1, 0x69, 0xb2, 0x2b, 0x5c,
	0x06, 0xe0, 0x0b, 0x6e, 0xf8, 0xe2, 0x3b, 0x81, 0xc9, 0x8e, 0x1b, 0x7a, 0x06, 0x23, 0x07, 0xea,
	0x88, 0xcc, 0xbd, 0x5d, 0x17, 0xee, 0x1f, 0xd9, 0x16, 0xa0, 0xcf, 0xe0, 0xbf, 0x54, 0x21, 0xc6,
	0xb7, 0xbc, 0xe0, 0x32, 0x69, 0xa7, 0xf4, 0xd9, 0xa4, 0xd1, 0x2e, 0x5b, 0x89, 0xbe, 0x80, 0x83,
	0x0a, 0xa5, 0xc8, 0x65, 0xb6, 0xa5, 0x3c, 0x4b, 0xcd, 0x9c, 0xdc, 0x81, 0x4b, 0x78, 0xca, 0xef,
	0x50, 0xf1, 0x0c, 0xdd, 0x40, 0x71, 0x5d, 0x09, 0x6e, 0x30, 0x16, 0xb5, 0xe2, 0x26, 0x2f, 0xa5,
	0x1d, 0xd0, 0x67, 0x4f, 0x1c, 0xd5, 0xce, 0xf1, 0xd1, 0x32, 0x6f, 0x1d, 0xb2, 0xf8, 0x4a, 0x60,
	0xe8, 0x6c, 0xd2, 0x87, 0x30, 0xac, 0x35, 0xaa, 0x38, 0x17, 0x36, 0x12, 0x9f, 0x05, 0x4d, 0x79,
	0x25, 0xe8, 0x31, 0x40, 0xf7, 0x74, 0xb9, 0x70, 0x9e, 0xc7, 0x4e, 0xb9, 0x12, 0xcd, 0x50, 0xb6,
	0x6f, 0xdf, 0xee, 0xa4, 0xd1, 0x3a, 0xaf, 0xcf, 0x61, 0xa6, 0xec, 0x9b, 0x6d, 0xa1, 0xd6, 0xdb,
	0xb4, 0x55, 0x3b, 0xec, 0x18, 0x20, 0xd7, 0xb1, 0x9b, 0x33, 0x1a, 0xcc, 0xc9, 0xc9, 0x88, 0x8d,
	0x73, 0x7d, 0xdd, 0x0a, 0x8b, 0x2f, 0x04, 0x86, 0x2e, 0x59, 0x7a, 0x0e, 0x41, 0xb3, 0x04, 0xb5,
	0xb6, 0x5e, 0x67, 0xbf, 0x62, 0x74, 0xc0, 0x8d, 0xbd, 0x64, 0x0e, 0xa2, 0x47, 0x10, 0x68, 0x94,
	0x02, 0x95, 0xb3, 0xef, 0x2a, 0xfa, 0x18, 0x46, 0x0a, 0x13, 0xcc, 0xef, 0x50, 0x39, 0xdf, 0xdb,
	0xba, 0xe9, 0xe1, 0xeb, 0xb2, 0x96, 0xc6, 0x3a, 0xf1, 0x99, 0xab, 0x1a, 0x1d, 0xb9, 0x92, 0x28,
	0xa2, 0xc0, 0x6e, 0xae, 0xab, 0x16, 0x3f, 0x08, 0x4c, 0xf7, 0x96, 0x88, 0x9e, 0x83, 0x6f, 0x36,
	0x15, 0x3a, 0x8b, 0x8f, 0xee, 0xdd, 0xb4, 0x0f, 0x9b, 0x0a, 0x99, 0xc5, 0x76, 0x03, 0xe8, 0xff,
	0x21, 0x00, 0xef, 0x6f, 0x01, 0xf8, 0xff, 0x12, 0xc0, 0xe0, 0xbe, 0x00, 0x42, 0xf0, 0x52, 0x44,
	0x3b, 0x97, 0xcf, 0x9a, 0xe3, 0xe9, 0x3b, 0x98, 0xee, 0xbd, 0x28, 0x9d, 0xc0, 0x50, 0xd7, 0x49,
	0x82, 0x5a, 0x87, 0x3d, 0x7a, 0x04, 0xb4, 0x96, 0xba, 0x4e, 0xd3, 0x3c, 0xc9, 0x51, 0x9a, 0x38,
	0xad, 0xa5, 0xd0, 0x21, 0xa1, 0x87, 0x30, 0xc5, 0xcf, 0x06, 0x95, 0xe4, 0x45, 0x9c, 0xf2, 0xbc,
	0x08, 0xfb, 0xa7, 0xaf, 0xe1, 0xf0, 0xb7, 0xb9, 0xe9, 0x08, 0xfc, 0xb2, 0x42, 0x19, 0xf6, 0xe8,
	0x18, 0x06, 0x49, 0x51, 0x6a, 0x0c, 0x09, 0x05, 0x08, 0x6a, 0x51, 0x71, 0x83, 0x61, 0xff, 0x36,
	0xb0, 0x9f, 0x8e, 0x57, 0x3f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x4a, 0x57, 0x90, 0x06, 0x47, 0x04,
	0x00, 0x00,
}
